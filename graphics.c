#include "graphics.h"
#include "gba.h"
#include "images/basicBackground.h"
#include "images/fBWUpRight.h"
#include "images/fBWUpLeft.h"
#include "images/fBWDownRight.h"
#include "images/fBWDownLeft.h"
#include "images/titleScreen.h"

// TA-TODO: Include any header files for images generated by nin10kit.
// Example for the provided garbage image:
//#include "images/garbage.h"

// TA-TODO: Add any draw/undraw functions for sub-elements of your app here.
// For example, for a snake game, you could have a drawSnake function
// or a drawFood function
//
// e.g.:
// static void drawSnake(Snake* snake);
// static void drawFood(Food* food);

// This function will be used to draw everything about the app
// including the background and whatnot.
void fullDrawAppState(AppState *state) {
    // TA-TODO: IMPLEMENT.
    drawFullScreenImageDMA(basicBackground); //draws starting background
    drawCenteredString(36, 6, 0, 0, "Ducks Left: ", GREEN);
    drawCenteredString(210, 6, 0, 0, "Score: ", GREEN);
    //Draws the starting ducks left
    drawChar(66, 2, (((state->ducksLeft) / 10) % 10) + 48, GREEN); //10s digit
    drawChar(72, 2, ((state->ducksLeft) % 10) + 48, GREEN); //1s digit
    //draws the starting score
    drawChar(225, 2, (((state->score) / 10) % 10) + 48, GREEN); //10s digit
    drawChar(231, 2, ((state->score) % 10) + 48, GREEN); //1s digit
    //draws initial position of pirate
    drawImageDMA(state->character->row, state->character->col, state->character->width, 
        state->character->height, state->character->image);
    // //test drawing for the flappybird
    // drawImageDMA(121, 50, 16, 16, fBWUpRight);
    // drawImageDMA(50, 100, 16, 16, fBWUpLeft);
    // drawImageDMA(25, 50, 16, 16, fBWDownRight);
    // drawImageDMA(25, 100, 16, 16, fBWDownLeft);
    //drawRectDMA(BIRD_SPAWN_HIGH_BOUND, 0, WIDTH, 1, RED);
}

// This function will be used to undraw (i.e. erase) things that might
// move in a frame. E.g. in a Snake game, erase the Snake, the food & the score.

//only use currentState to make comparisons to see changes between states
//only change currentState when 
void undrawAppState(AppState *pastState, AppState *currentState) {
    // TA-TODO: IMPLEMENT.

    //undraws the last chars for ducks left if there are any changes
    if (pastState->ducksLeft != currentState->ducksLeft) {
        drawChar(66, 2, (((pastState->ducksLeft) / 10) % 10) + 48, BLACK); //10s digit
        drawChar(72, 2, ((pastState->ducksLeft) % 10) + 48, BLACK); //1s digit
    }

    //undraws the last chars for ducks left if there are any changes
    if (pastState->score != currentState->score) {
        drawChar(225, 2, (((pastState->score) / 10) % 10) + 48, BLACK); //10s digit
        drawChar(231, 2, ((pastState->score) % 10) + 48, BLACK); //1s digit
    }

    // Checks if the character moved sideways. If it did, updates accordingly
    if (pastState->character->movedRight) {
        if (pastState->character->movedRight == -1) {
            drawRectDMA(pastState->character->row, pastState->character->col + pastState->character->width, 
                2, pastState->character->height, MARSH);
        } else {
            drawRectDMA(pastState->character->row, pastState->character->col - 2, 
                2, pastState->character->height, MARSH);
        }
    }

    // Undraws the character if it moved up or down.
    if (pastState->character->movedDown) {
        if (pastState->character->movedDown == -1) {
            drawRectDMA(pastState->character->row + pastState->character->height, pastState->character->col,
                pastState->character->width, 1, MARSH);
        } else {
            drawRectDMA(pastState->character->row - 1, pastState->character->col,
                pastState->character->width, 1, MARSH);
        }
    }

    //deals with the edge cased associated with diagonal movement
    if (pastState->character->movedRight && pastState->character->movedDown) {
        if (pastState->character->movedRight == 1) {
            if (pastState->character->movedDown == 1) {
                setPixel(pastState->character->col - 2, 
                    pastState->character->row - 1, MARSH);
                setPixel(pastState->character->col - 1, 
                    pastState->character->row - 1, MARSH);
            } else {
                setPixel(pastState->character->col - 2, 
                    pastState->character->row + pastState->character->height, MARSH);
                setPixel(pastState->character->col - 1, 
                    pastState->character->row + pastState->character->height, MARSH);
            }
        } else {
            if (pastState->character->movedDown == 1) {
                setPixel(pastState->character->col + pastState->character->width, 
                    pastState->character->row - 1, MARSH);
                setPixel(pastState->character->col + pastState->character->width + 1, 
                    pastState->character->row - 1, MARSH);
            } else {
                setPixel(pastState->character->col + pastState->character->width, 
                    pastState->character->row + pastState->character->height, MARSH);
                setPixel(pastState->character->col + pastState->character->width + 1, 
                    pastState->character->row + pastState->character->height, MARSH);
            }
        }
    }

    //undraws any bullet that is on the screen at that moment
    if (vBlankCounter % B_VEL == 0 
        && pastState->bulletsFront != pastState->bulletsBack) {
        //int bounds = pastState->bulletsFront + NUM_BULLETS;
        for (int i = 0; i < NUM_BULLETS; i++) {
            if (pastState->bullets[i % NUM_BULLETS].isUsed && pastState->bullets[i % NUM_BULLETS].row < STARTING_CHAR_ROW - B_HEIGHT + 1) {
                if (pastState->bullets[i % NUM_BULLETS].row - B_HEIGHT < B_BOUNDS || pastState->bullets[i % NUM_BULLETS].hit) {
                    currentState->bullets[i % NUM_BULLETS].isUsed = 0;
                    currentState->bulletsFront++;
                }
                drawFromImageDMA(pastState->bullets[i % NUM_BULLETS].row + B_HEIGHT - 1, pastState->bullets[i % NUM_BULLETS].col,
                    pastState->bullets[i % NUM_BULLETS].width, pastState->bullets[i % NUM_BULLETS].height, basicBackground);
            }
        }        
    }

    //undraws the back of the bird in flight
    if (vBlankCounter % BIRD_VEL == 0
        && pastState->birdsFront != pastState->birdsBack) {
        for (int i = 0; i < NUM_BIRDS; i++) {
            if (pastState->birds[i % NUM_BIRDS].velocity != 0) {
                if (pastState->birds[i % NUM_BIRDS].velocity > 0) {
                    if (pastState->birds[i % NUM_BIRDS].col + FBWUPLEFT_WIDTH + pastState->birds[i % NUM_BIRDS].velocity < WIDTH 
                        && !pastState->birds[i % NUM_BIRDS].hit) {
                        drawFromImageDMA(pastState->birds[i % NUM_BIRDS].row, 
                            pastState->birds[i % NUM_BIRDS].col - pastState->birds[i % NUM_BIRDS].velocity,
                            pastState->birds[i % NUM_BIRDS].velocity, FBWUPLEFT_HEIGHT, basicBackground);
                    } else {
                        drawFromImageDMA(pastState->birds[i % NUM_BIRDS].row, 
                             pastState->birds[i % NUM_BIRDS].col - pastState->birds[i % NUM_BIRDS].velocity,
                             FBWUPLEFT_WIDTH, FBWUPLEFT_HEIGHT, basicBackground);
                        currentState->birds[i % NUM_BIRDS].velocity = 0;
                        currentState->birdsFront++;
                    }
                } else {
                    if (pastState->birds[i % NUM_BIRDS].col + pastState->birds[i % NUM_BIRDS].velocity > 0 
                        && !pastState->birds[i % NUM_BIRDS].hit) {
                        drawFromImageDMA(pastState->birds[i % NUM_BIRDS].row, 
                            pastState->birds[i % NUM_BIRDS].col + FBWUPLEFT_WIDTH,
                            pastState->birds[i % NUM_BIRDS].velocity * -1, FBWUPLEFT_HEIGHT, basicBackground);
                    } else {
                        drawFromImageDMA(pastState->birds[i % NUM_BIRDS].row, 
                             pastState->birds[i % NUM_BIRDS].col - pastState->birds[i % NUM_BIRDS].velocity,
                             FBWUPLEFT_WIDTH, FBWUPLEFT_HEIGHT, basicBackground);
                        currentState->birds[i % NUM_BIRDS].velocity = 0;
                        currentState->birdsFront++;
                    }
                }
            }
        }
    }
}

// This function will be used to draw things that might have moved in a frame.
// For example, in a Snake game, draw the snake, the food, the score.
void drawAppState(AppState *pastState, AppState *currentState) {
    // TA-TODO: IMPLEMENT.

    //undraws the last chars for ducks left if there are any changes
    if (pastState->ducksLeft != currentState->ducksLeft) {
        drawChar(66, 2, (((currentState->ducksLeft) / 10) % 10) + 48, GREEN); //10s digit
        drawChar(72, 2, ((currentState->ducksLeft) % 10) + 48, GREEN); //1s digit
    }

    //undraws the last chars for ducks left if there are any changes
    if (pastState->score != currentState->score) {
        drawChar(225, 2, (((currentState->score) / 10) % 10) + 48, GREEN); //10s digit
        drawChar(231, 2, ((currentState->score) % 10) + 48, GREEN); //1s digit
    }

    //draws the character again if it moved 
    if (pastState->character->movedRight || pastState->character->movedDown) {
        drawImageDMA(currentState->character->row, currentState->character->col, 
            currentState->character->width, currentState->character->height, 
            currentState->character->image);
    }

    //draws the bullets
    //makes sure you always travers the array only for how many bullets are moving
    if (vBlankCounter % B_VEL == 0 
        && currentState->bulletsFront != currentState->bulletsBack) {
        //int bounds = currentState->bulletsFront + NUM_BULLETS;
        for (int i = 0; i < NUM_BULLETS; i++) {
            if (currentState->bullets[i % NUM_BULLETS].isUsed) {
                drawRectDMA(currentState->bullets[i % NUM_BULLETS].row, currentState->bullets[i % NUM_BULLETS].col,
                    currentState->bullets[i % NUM_BULLETS].width, currentState->bullets[i % NUM_BULLETS].height, YELLOW);
            }
        }        
    }

    if (vBlankCounter % BIRD_VEL == 0
        && currentState->birdsFront != currentState->birdsBack) {
        //int bounds = currentState->birdsFront + NUM_BIRDS;
        for (int i = 0; i < NUM_BIRDS; i++) {
            if (currentState->birds[i % NUM_BIRDS].velocity != 0) {
                if (currentState->birds[i % NUM_BIRDS].wingSwitch < SWITCH_TIME / 2) { //switches the wings
                    drawImageDMA(currentState->birds[i % NUM_BIRDS].row, currentState->birds[i % NUM_BIRDS].col, 
                        FBWUPLEFT_WIDTH, FBWUPLEFT_HEIGHT, currentState->birds[i % NUM_BIRDS].wingUp);
                } else if (currentState->birds[i % NUM_BIRDS].wingSwitch >= SWITCH_TIME / 2) {
                    drawImageDMA(currentState->birds[i % NUM_BIRDS].row, currentState->birds[i % NUM_BIRDS].col, 
                        FBWUPLEFT_WIDTH, FBWUPLEFT_HEIGHT, currentState->birds[i % NUM_BIRDS].wingDown);
                }
                if (currentState->birds[i % NUM_BIRDS].wingSwitch > 0) {
                    currentState->birds[i % NUM_BIRDS].wingSwitch--;
                } else {
                    currentState->birds[i % NUM_BIRDS].wingSwitch = SWITCH_TIME;
                }
            }
            // } else {
            //     if (i == currentState->birdsFront) {
            //         drawRectDMA(50,50,25,25,BLACK);
            //         drawChar(60,60, currentState->birdsBack + 48, GREEN);
            //         currentState->lastBirdSpawned = -1;
            //     }
            //     break;
            // }
        }
    }
}

// Draws the introductory screen that contains the title and instructions for how
// to play
void drawStartScreen(void) {
    drawFullScreenImageDMA(titleScreen);
	// drawCenteredString(100, 30, 50, 50, "Press button A (Z on keyboard)", GREEN);
 //    drawCenteredString(100, 45, 50, 50, "to continue", GREEN);
    drawCenteredString(120, 9, 0, 0, "Welcome to", WHITE);
    drawCenteredString(120, 60, 0, 0, "HALFTIME HUNT!", WHITE);
    drawCenteredString(120, 140, 0, 0, "Press A (z on keyboard) to continue!", WHITE);
}

void drawEndingScreen(AppState *endingState) {
    fillScreenDMA(BLACK);
    drawCenteredString(120, 30, 0, 0, "Game Over! Congrats!", GREEN);
    drawCenteredString(115, 50, 0, 0, "Your Score: ", GREEN);
    drawChar(145, 46, (((endingState->score) / 10) % 10) + 48, GREEN);
    drawChar(151, 46, ((endingState->score) % 10) + 48, GREEN);
    drawCenteredString(120, 70, 0, 0, "Press select", GREEN);
    drawCenteredString(120, 90, 0, 0, "(back space on keyboard)", GREEN);
    drawCenteredString(120, 110, 0, 0, "to play again!", GREEN);
}

void drawInstructionScreen(void) {
    fillScreenDMA(BLACK);
    drawCenteredString(120, 15, 0, 0, "INSTRUCTIONS: ", GREEN);
    drawCenteredString(105, 35, 0, 0, "1. Use arrows to move your gun!", GREEN);
    drawCenteredString(120, 55, 0, 0, "2. Press B (x on keyboard) to shoot!", GREEN);
    drawCenteredString(102, 75, 0, 0, "3. Faster birds = more points!", GREEN);
    drawCenteredString(120, 105, 0, 0, "Press A (z on keyboard) to start!", GREEN);
}